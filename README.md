目的是大四毕业成为一名嵌入式软件工程师
<img width="979" height="795" alt="Snipaste_2026-01-13_20-23-48" src="https://github.com/user-attachments/assets/2c5f95ab-7ae1-4388-a098-3b1f90b69573" />

这个图是STM32 F103 系列的系统架构图，核心展示了芯片内部各模块的连接关系与数据传输逻辑，先明确图里的基础标识：
黄色模块：驱动单元（主动发起数据传输的模块）
粉色模块：被动单元（接收数据传输的模块）
一、核心模块与连接逻辑
1. 驱动单元（黄色）
是主动发起数据传输的 “发起者”，包含 3 个核心部分：
Cortex-M3 内核：通过 3 组总线（ICode、DCode、System）与总线矩阵通信，负责执行代码、处理数据。
DMA1：含 7 个通道，负责低 / 中速外设的数据搬运。
DMA2：含 5 个通道（仅大容量 STM32F103 有），负责高速外设的数据搬运。
2. 被动单元（粉色）
是接收数据传输的 “响应者”，包含：
Flash：存储程序代码 / 只读数据；
SRAM：存储运行时的变量 / 临时数据；
FSMC/SDIO：外部存储（如外接 SRAM、SD 卡）的接口；
各类外设：挂在 APB1/APB2 总线上的模块（如 USART 串口、TIM 定时器、ADC 模数转换等）。
3. 总线架构（数据传输的 “通路”）
总线矩阵：是核心 “交通枢纽”，负责调度驱动单元到被动单元的所有数据传输（避免总线冲突）。
AHB 系统总线：高速总线，连接总线矩阵、FSMC、SDIO、RCC（复位和时钟控制）。
APB1/APB2 总线：低速外设总线（APB2 速度比 APB1 快），通过 “桥接 1/2” 与 AHB 总线连接，挂接各类外设。
4. DMA 的工作逻辑（图中 “DMA 请求” 部分）
外设（如 USART、ADC）需要传输数据时，会向 DMA1/DMA2 发送 “DMA 请求”；
DMA 收到请求后，通过总线矩阵直接搬运数据（比如：外设→SRAM、SRAM→外设、Flash→SRAM），全程不需要 CPU 参与，从而解放 CPU 资源。

5.5 寄存器映射 

一、寄存器映射的核心定义
寄存器映射是把 STM32 芯片里硬件寄存器的物理地址，用 C 语言的 “标识符（变量 / 结构体成员）” 来替代的过程。简单说就是给硬件寄存器 “起个好记的名字”，不用直接记忆和操作复杂的十六进制物理地址。
举个通俗例子：
物理地址：GPIOA 端口的配置寄存器地址是0x40010800（难记、易写错）；
寄存器映射后：用GPIOA->CRL（GPIOA 的配置寄存器低半部分）代替这个地址，直观又好记，操作GPIOA->CRL就等同于直接操作硬件寄存器。
二、寄存器映射的实现逻辑（结合存储器映射）
寄存器映射是基于我们之前聊的 “存储器区域划分” 实现的，核心分 3 步：
硬件层面：STM32 把所有外设（GPIO、USART、DMA 等）的寄存器，都分配在 “片上外设区（Block2：0x4000 0000~0x5FFF FFFF）” 的固定物理地址上；
代码层面：用 C 语言结构体定义外设的寄存器组，结构体的每个成员对应一个寄存器，且成员的内存地址和硬件寄存器的物理地址严格对齐；
别名简化：给结构体变量取一个直观的别名（如GPIOA、USART1），最终通过 “别名 -> 成员” 的方式操作寄存器。
